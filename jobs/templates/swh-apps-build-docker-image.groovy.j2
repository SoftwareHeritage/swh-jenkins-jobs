def application = params.APPLICATION
def dry_run = params.DRY_RUN
def cleanup_image = params.CLEANUP_IMAGE
// For local build, use 'docker' label, else 'built-in' (the default, e.g. for prod)
def label_node = params.NODE

def frozen_set_filepath = "apps/${application}/requirements-frozen.txt"
def dockerfile_filepath = "apps/${application}/Dockerfile"

// The following is configured in jenkins manually:
// > Manage Jenkins > Configure System > Declarative pipeline (Docker)
// Input the information in the form
// container-registry: container-registry.softwareheritage.org
// Registry credentials: select the pat token created for the occasion for the gitlab's
// (username/password credentials created for the occasion, username: jenkins, password
// the pat token)
// Docker label: gitlab-registry
// jenkins user in gitlab.s.o (permissions: Read+Write access to registry)
// then click the 'Add' button

def registry_domain = "container-registry.softwareheritage.org/swh/infra/swh-apps"
def dockerCredentialsKeyID = 'gitlab-registry'

// swh-loader-git: loader_git
// swh-storage-replayer: storage_replayer
// ...
def image_name = application.replaceAll('-', '_').replaceAll('swh_', '')
echo "image name to build: ${image_name}"

// Determine the following during the job execution
def application_tag
def image_version
def full_image_version

def git_log = 'git log | head -10'
def repository_prefix_url

pipeline {
  // Where to make the job run
  agent { label label_node }

  stages {
    stage('Checkout swh-apps repository') {
      steps {
        script {
          repository_prefix_url = dry_run ? "{{gitlab_url}}/" : "{{gitlab_ssh_url}}:"
        }
        checkout([
          $class: 'GitSCM',
          userRemoteConfigs: [[
            credentialsId: 'gitlab-public-ci-ssh',
            name: 'origin',
            url: "${repository_prefix_url}{{gitlab_project_name}}.git",
          ]],
          extensions: [[$class: 'CloneOption', depth: 1, shallow: false],
                       [$class: 'LocalBranch', localBranch: "**"]],
          doGenerateSubmoduleConfigurations: false,
          gitTool: 'Default',
          submoduleCfg: [],
          branches: [[
            name: "master"
          ]],
        ])
        // FIXME: Determine the proper way to declare this directly with gitscm above
        sh "git branch --set-upstream-to=origin/master"
      }
    }

    // FIXME: Build and push directly this image in the registry (built daily) and use
    // it directly here
    stage('Build/Reuse "app-manager" image') {
      steps {
        sh 'docker build --pull --build-arg userid=`id -u` --build-arg groupid=`id -g` -t app-manager scripts/'
      }
    }

    stage('Build frozen requirements sets') {
      steps {
        script {
          sh """
            echo "Before build frozen requirements set"
            git status
            git diff
          """
          sh "docker run -v `pwd`:/src app-manager generate-frozen-requirements ${application}"

          sh """
            echo "Before stash instruction"
            git status
            git diff
          """
          stash name: "${application}-requirements-frozen", includes: frozen_set_filepath
          sh """
            echo "After stash instruction"
            git status
            git diff
          """
        }
      }
    }

    stage('Commit and declare swh-apps tag') {
      steps {
        script {
          sh """
            ${git_log}
            echo `pwd`
          """
          application_tag = sh (
            script: "docker run -v `pwd`:/src app-manager tag next '${application}'",
            returnStdout: true
          ).trim()
          echo """
            application tag: ${application_tag}
            next tag for ${application}: ${application_tag}
            image name: ${image_name}
          """
          image_version = application_tag.replaceAll("${application}-", "")
          echo """
            image version: ${image_version}
            frozen set filepath: ${frozen_set_filepath}
          """
          sh """
            git status
            git diff
            git checkout master
          """
          unstash "${application}-requirements-frozen"
          dockerfile_exists = fileExists(dockerfile_filepath)
          if ( dockerfile_exists ) {
            commit_msg = "'${application}-${image_version}: Build image with frozen set requirements'"
          } else {
            commit_msg = "'${application}-${image_version}: Update frozen set requirements'"
          }
          sh """
            git add ${frozen_set_filepath}
            # Skipping empty commit to ease reproducibility even without changes
            git commit --no-verify -m ${commit_msg} || echo "Skip empty commit"
            ${git_log}
          """
        }
      }
    }

    stage('Docker image build') {
      steps {
        script {
          if ( dockerfile_exists ) {
            // Determine docker image name and version
            full_image_version = "${registry_domain}/${image_name}:${image_version}"
            echo "full image version: ${full_image_version}"
            sh "docker build --tag ${full_image_version} apps/${application}"
          }
        }
      }
    }

    stage('Git tag & push') {
      steps {
        script {
          if ( ! dry_run ) {
            sshagent (credentials: ['gitlab-public-ci-ssh']) {
              sh """
                git pull --rebase
                # FIXME: Improve tag message with the impacted module python version actually
                # released (grep <app> requirements-frozen.txt, cat requirements-frozen.txt...)
                git tag -a ${application_tag} -m "${application_tag}: Bump new release"
                git push origin master ${application_tag}
              """
            }
          } else {
            echo "Skipping `git push`."
          }
        }
      }
    }

    // TODO: Determine how to and trigger tests on built image
    // stage('Test docker image') {}

    stage('Push image in registry') {
      steps {
        script {
          if ( ! dry_run && dockerfile_exists ) {
            docker.withRegistry("https://${registry_domain}", dockerCredentialsKeyID) {
              sh "docker push ${full_image_version}"
            }
          } else {
            echo "Skipping `docker image push`."
          }
        }
      }
    }
  }

  post {
    cleanup {
      cleanWs()
    }
    always {
      script {
        if ( dockerfile_exists && cleanup_image ) {
          sh "docker image rm ${full_image_version}"
        }
      }
    }
  }
}
