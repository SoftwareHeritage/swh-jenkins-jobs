// Whether we do the publication step
def publish_ok = not params.dry_run

{% include 'includes/trigger-build.groovy.j2' %}

pipeline {
  {% filter indent(width=2) %}
    {%- include 'includes/agent-docker.groovy.j2' -%}
  {% endfilter %}

  environment {
    RUSTC_WRAPPER = 'sccache'
    CARGO_INCREMENTAL = '0'
    RUSTFLAGS = "-C target-cpu={{ rust_cpu_target }}"
  }

  stages {
    stage('Run tests') {
      when {
        expression { return !params.SKIP_TESTS }
        beforeAgent true
      }
      agent none
      steps {
        triggerBuild(
          job: '/rust/{{name}}/gitlab-builds',
          parameters: [
            string(name: 'REVISION', value: params.GIT_TAG),
          ],
          propagate: !params.IGNORE_TESTS,
        )
      }
    }

    stage('Checkout') {
      steps {
        checkout([
          $class: 'GitSCM',
          userRemoteConfigs: [[
            name:'origin', url: '{{gitlab_url}}/{{gitlab_project_name}}.git',
            refspec: '+refs/tags/*:refs/remotes/origin/tags*'
          ]],
          branches: [[
            name: "${params.GIT_TAG}"
          ]],
          extensions: [
            [$class: 'CloneOption', honorRefspec: true],
            [
              $class: 'SubmoduleOption',
              disableSubmodules: false,
              recursiveSubmodules: true,
            ]
          ],
          extensions: [],
          gitTool: 'Default',
        ])
      }
    }

    stage('(DryRun) Publish locally - Checks cargo package step is ok') {
      steps {
        {% if production_jenkins %}
        withCredentials([
          string(credentialsId: 'sccache-redis-endpoint', variable: 'SCCACHE_REDIS_ENDPOINT'),
          string(credentialsId: 'sccache-redis-password', variable: 'SCCACHE_REDIS_PASSWORD'),
        ]) {
        {% endif %}
        // Use a local cargo registry to publish crates
        sh """#!/bin/bash
        prepare-cargo-cache
        cargo install cargo-local-registry cargo-http-registry
        # copy all dependencies to a local cargo registry
        cargo local-registry --sync Cargo.lock /tmp/cargo-registry/
        # execute service in background for publishing to local registry
        cargo-http-registry /tmp/cargo-registry &
        # update cargo config to replace crates.io registry by the local one
        mkdir -p .cargo
        cat > .cargo/config.toml <<EOL
[registries]
local-registry = { index = 'file:////tmp/cargo-registry' }

[source.crates-io]
registry = 'sparse+https://index.crates.io/'
replace-with = 'local-registry'

[source.local-registry]
local-registry = '/tmp/cargo-registry/'
EOL
        """
        // Check whether all crates from the repositories are crate compliant
        {% for crate in crate_names %}
          sh '''#!/bin/bash
          export CARGO_REGISTRIES_LOCAL_REGISTRY_TOKEN=foo
          # try to parse version from "path+file://<crate_path>@<crate_version>"
          crate_version=$(cargo pkgid -p {{crate}} | cut -d@ -f2)
          if [[ ! $crate_version =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]
          then
            # try to parse version from "path+file://<crate_path>#<crate_version>"
            crate_version=$(cargo pkgid -p {{crate}} | cut -d# -f2)
          fi
          if [[ ! $crate_version =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]
          then
            # crate version could not be parsed, abort to avoid entering in an infinite loop
            echo "Could not parse crate version, exiting"
            exit 1
          fi
          if cargo publish --locked --registry=local-registry -p {{crate}}
          then
            # update local registry index to include freshly built crate
            mv /tmp/cargo-registry/$(echo {{crate}} | cut -c1-2) /tmp/cargo-registry/index
            # check freshly built crate is available in index
            until cargo info --registry=local-registry {{crate}} | grep "^version: ${crate_version}"; do sleep 10; done
          else
            exit 1
          fi
          '''
        {% endfor %}
        // remove custom cargo config
        sh "rm .cargo/config.toml"
        {% if production_jenkins %}
        }
        {% endif %}
      }
    }

    {% if production_jenkins %}
    stage('Publish') {
      when {
        // and we are ok to publish
        expression { publish_ok }
      }
      steps {
        // Then we are go to publish the crates
        withCredentials([
          string(credentialsId: 'swhmirror-crates-api-token',
                 variable: 'CARGO_REGISTRY_TOKEN'),
          string(credentialsId: 'sccache-redis-endpoint', variable: 'SCCACHE_REDIS_ENDPOINT'),
          string(credentialsId: 'sccache-redis-password', variable: 'SCCACHE_REDIS_PASSWORD')]) {
          {% for crate in crate_names %}
            sh '''#!/bin/bash
            prepare-cargo-cache
            # try to parse version from "path+file://<crate_path>@<crate_version>"
            crate_version=$(cargo pkgid -p {{crate}} | cut -d@ -f2)
            if [[ ! $crate_version =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]
            then
              # try to parse version from "path+file://<crate_path>#<crate_version>"
              crate_version=$(cargo pkgid -p ar_row | cut -d# -f2)
            fi
            if [[ ! $crate_version =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]
            then
              # crate version could not be parsed, abort to avoid entering in an infinite loop
              echo "Could not parse crate version, exiting"
              exit 1
            fi
            if cargo search {{crate}} | grep "^{{crate}} = \\\"${crate_version}\\\""
            then
              echo "Crate {{crate}} with version ${crate_version} already published, nothing to do."
            else
              if cargo publish --locked -p {{crate}}
              then
                # ensure crate got published before publishing the next ones
                until cargo search {{crate}} | grep "^{{crate}} = \\\"${crate_version}\\\""; do sleep 10; done
              else
                exit 1
              fi
            fi
            '''
          {% endfor %}
        }
      }
    }
    {% endif %}
  }
  post {
    cleanup {
      cleanWs()
    }
  }
}
